// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'firestore_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$FirestoreFailureTearOff {
  const _$FirestoreFailureTearOff();

  Unexpected unexpected() {
    return const Unexpected();
  }

  UserNameAlreadyExits userNameAlreadyExits() {
    return const UserNameAlreadyExits();
  }

  InsufficientPermissions insufficientPermissions() {
    return const InsufficientPermissions();
  }

  UnableToUpdate unableToUpdate() {
    return const UnableToUpdate();
  }

  DoesNotExist doesNotExist() {
    return const DoesNotExist();
  }

  NoInternet noInternet() {
    return const NoInternet();
  }

  NoPhotos noPhotos() {
    return const NoPhotos();
  }
}

/// @nodoc
const $FirestoreFailure = _$FirestoreFailureTearOff();

/// @nodoc
mixin _$FirestoreFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() userNameAlreadyExits,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() doesNotExist,
    required TResult Function() noInternet,
    required TResult Function() noPhotos,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? userNameAlreadyExits,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? doesNotExist,
    TResult Function()? noInternet,
    TResult Function()? noPhotos,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(UserNameAlreadyExits value) userNameAlreadyExits,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(DoesNotExist value) doesNotExist,
    required TResult Function(NoInternet value) noInternet,
    required TResult Function(NoPhotos value) noPhotos,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(UserNameAlreadyExits value)? userNameAlreadyExits,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(DoesNotExist value)? doesNotExist,
    TResult Function(NoInternet value)? noInternet,
    TResult Function(NoPhotos value)? noPhotos,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FirestoreFailureCopyWith<$Res> {
  factory $FirestoreFailureCopyWith(
          FirestoreFailure value, $Res Function(FirestoreFailure) then) =
      _$FirestoreFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$FirestoreFailureCopyWithImpl<$Res>
    implements $FirestoreFailureCopyWith<$Res> {
  _$FirestoreFailureCopyWithImpl(this._value, this._then);

  final FirestoreFailure _value;
  // ignore: unused_field
  final $Res Function(FirestoreFailure) _then;
}

/// @nodoc
abstract class $UnexpectedCopyWith<$Res> {
  factory $UnexpectedCopyWith(
          Unexpected value, $Res Function(Unexpected) then) =
      _$UnexpectedCopyWithImpl<$Res>;
}

/// @nodoc
class _$UnexpectedCopyWithImpl<$Res>
    extends _$FirestoreFailureCopyWithImpl<$Res>
    implements $UnexpectedCopyWith<$Res> {
  _$UnexpectedCopyWithImpl(Unexpected _value, $Res Function(Unexpected) _then)
      : super(_value, (v) => _then(v as Unexpected));

  @override
  Unexpected get _value => super._value as Unexpected;
}

/// @nodoc
class _$Unexpected implements Unexpected {
  const _$Unexpected();

  @override
  String toString() {
    return 'FirestoreFailure.unexpected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Unexpected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() userNameAlreadyExits,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() doesNotExist,
    required TResult Function() noInternet,
    required TResult Function() noPhotos,
  }) {
    return unexpected();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? userNameAlreadyExits,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? doesNotExist,
    TResult Function()? noInternet,
    TResult Function()? noPhotos,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(UserNameAlreadyExits value) userNameAlreadyExits,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(DoesNotExist value) doesNotExist,
    required TResult Function(NoInternet value) noInternet,
    required TResult Function(NoPhotos value) noPhotos,
  }) {
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(UserNameAlreadyExits value)? userNameAlreadyExits,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(DoesNotExist value)? doesNotExist,
    TResult Function(NoInternet value)? noInternet,
    TResult Function(NoPhotos value)? noPhotos,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class Unexpected implements FirestoreFailure {
  const factory Unexpected() = _$Unexpected;
}

/// @nodoc
abstract class $UserNameAlreadyExitsCopyWith<$Res> {
  factory $UserNameAlreadyExitsCopyWith(UserNameAlreadyExits value,
          $Res Function(UserNameAlreadyExits) then) =
      _$UserNameAlreadyExitsCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserNameAlreadyExitsCopyWithImpl<$Res>
    extends _$FirestoreFailureCopyWithImpl<$Res>
    implements $UserNameAlreadyExitsCopyWith<$Res> {
  _$UserNameAlreadyExitsCopyWithImpl(
      UserNameAlreadyExits _value, $Res Function(UserNameAlreadyExits) _then)
      : super(_value, (v) => _then(v as UserNameAlreadyExits));

  @override
  UserNameAlreadyExits get _value => super._value as UserNameAlreadyExits;
}

/// @nodoc
class _$UserNameAlreadyExits implements UserNameAlreadyExits {
  const _$UserNameAlreadyExits();

  @override
  String toString() {
    return 'FirestoreFailure.userNameAlreadyExits()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UserNameAlreadyExits);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() userNameAlreadyExits,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() doesNotExist,
    required TResult Function() noInternet,
    required TResult Function() noPhotos,
  }) {
    return userNameAlreadyExits();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? userNameAlreadyExits,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? doesNotExist,
    TResult Function()? noInternet,
    TResult Function()? noPhotos,
    required TResult orElse(),
  }) {
    if (userNameAlreadyExits != null) {
      return userNameAlreadyExits();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(UserNameAlreadyExits value) userNameAlreadyExits,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(DoesNotExist value) doesNotExist,
    required TResult Function(NoInternet value) noInternet,
    required TResult Function(NoPhotos value) noPhotos,
  }) {
    return userNameAlreadyExits(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(UserNameAlreadyExits value)? userNameAlreadyExits,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(DoesNotExist value)? doesNotExist,
    TResult Function(NoInternet value)? noInternet,
    TResult Function(NoPhotos value)? noPhotos,
    required TResult orElse(),
  }) {
    if (userNameAlreadyExits != null) {
      return userNameAlreadyExits(this);
    }
    return orElse();
  }
}

abstract class UserNameAlreadyExits implements FirestoreFailure {
  const factory UserNameAlreadyExits() = _$UserNameAlreadyExits;
}

/// @nodoc
abstract class $InsufficientPermissionsCopyWith<$Res> {
  factory $InsufficientPermissionsCopyWith(InsufficientPermissions value,
          $Res Function(InsufficientPermissions) then) =
      _$InsufficientPermissionsCopyWithImpl<$Res>;
}

/// @nodoc
class _$InsufficientPermissionsCopyWithImpl<$Res>
    extends _$FirestoreFailureCopyWithImpl<$Res>
    implements $InsufficientPermissionsCopyWith<$Res> {
  _$InsufficientPermissionsCopyWithImpl(InsufficientPermissions _value,
      $Res Function(InsufficientPermissions) _then)
      : super(_value, (v) => _then(v as InsufficientPermissions));

  @override
  InsufficientPermissions get _value => super._value as InsufficientPermissions;
}

/// @nodoc
class _$InsufficientPermissions implements InsufficientPermissions {
  const _$InsufficientPermissions();

  @override
  String toString() {
    return 'FirestoreFailure.insufficientPermissions()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InsufficientPermissions);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() userNameAlreadyExits,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() doesNotExist,
    required TResult Function() noInternet,
    required TResult Function() noPhotos,
  }) {
    return insufficientPermissions();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? userNameAlreadyExits,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? doesNotExist,
    TResult Function()? noInternet,
    TResult Function()? noPhotos,
    required TResult orElse(),
  }) {
    if (insufficientPermissions != null) {
      return insufficientPermissions();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(UserNameAlreadyExits value) userNameAlreadyExits,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(DoesNotExist value) doesNotExist,
    required TResult Function(NoInternet value) noInternet,
    required TResult Function(NoPhotos value) noPhotos,
  }) {
    return insufficientPermissions(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(UserNameAlreadyExits value)? userNameAlreadyExits,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(DoesNotExist value)? doesNotExist,
    TResult Function(NoInternet value)? noInternet,
    TResult Function(NoPhotos value)? noPhotos,
    required TResult orElse(),
  }) {
    if (insufficientPermissions != null) {
      return insufficientPermissions(this);
    }
    return orElse();
  }
}

abstract class InsufficientPermissions implements FirestoreFailure {
  const factory InsufficientPermissions() = _$InsufficientPermissions;
}

/// @nodoc
abstract class $UnableToUpdateCopyWith<$Res> {
  factory $UnableToUpdateCopyWith(
          UnableToUpdate value, $Res Function(UnableToUpdate) then) =
      _$UnableToUpdateCopyWithImpl<$Res>;
}

/// @nodoc
class _$UnableToUpdateCopyWithImpl<$Res>
    extends _$FirestoreFailureCopyWithImpl<$Res>
    implements $UnableToUpdateCopyWith<$Res> {
  _$UnableToUpdateCopyWithImpl(
      UnableToUpdate _value, $Res Function(UnableToUpdate) _then)
      : super(_value, (v) => _then(v as UnableToUpdate));

  @override
  UnableToUpdate get _value => super._value as UnableToUpdate;
}

/// @nodoc
class _$UnableToUpdate implements UnableToUpdate {
  const _$UnableToUpdate();

  @override
  String toString() {
    return 'FirestoreFailure.unableToUpdate()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UnableToUpdate);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() userNameAlreadyExits,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() doesNotExist,
    required TResult Function() noInternet,
    required TResult Function() noPhotos,
  }) {
    return unableToUpdate();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? userNameAlreadyExits,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? doesNotExist,
    TResult Function()? noInternet,
    TResult Function()? noPhotos,
    required TResult orElse(),
  }) {
    if (unableToUpdate != null) {
      return unableToUpdate();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(UserNameAlreadyExits value) userNameAlreadyExits,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(DoesNotExist value) doesNotExist,
    required TResult Function(NoInternet value) noInternet,
    required TResult Function(NoPhotos value) noPhotos,
  }) {
    return unableToUpdate(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(UserNameAlreadyExits value)? userNameAlreadyExits,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(DoesNotExist value)? doesNotExist,
    TResult Function(NoInternet value)? noInternet,
    TResult Function(NoPhotos value)? noPhotos,
    required TResult orElse(),
  }) {
    if (unableToUpdate != null) {
      return unableToUpdate(this);
    }
    return orElse();
  }
}

abstract class UnableToUpdate implements FirestoreFailure {
  const factory UnableToUpdate() = _$UnableToUpdate;
}

/// @nodoc
abstract class $DoesNotExistCopyWith<$Res> {
  factory $DoesNotExistCopyWith(
          DoesNotExist value, $Res Function(DoesNotExist) then) =
      _$DoesNotExistCopyWithImpl<$Res>;
}

/// @nodoc
class _$DoesNotExistCopyWithImpl<$Res>
    extends _$FirestoreFailureCopyWithImpl<$Res>
    implements $DoesNotExistCopyWith<$Res> {
  _$DoesNotExistCopyWithImpl(
      DoesNotExist _value, $Res Function(DoesNotExist) _then)
      : super(_value, (v) => _then(v as DoesNotExist));

  @override
  DoesNotExist get _value => super._value as DoesNotExist;
}

/// @nodoc
class _$DoesNotExist implements DoesNotExist {
  const _$DoesNotExist();

  @override
  String toString() {
    return 'FirestoreFailure.doesNotExist()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is DoesNotExist);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() userNameAlreadyExits,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() doesNotExist,
    required TResult Function() noInternet,
    required TResult Function() noPhotos,
  }) {
    return doesNotExist();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? userNameAlreadyExits,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? doesNotExist,
    TResult Function()? noInternet,
    TResult Function()? noPhotos,
    required TResult orElse(),
  }) {
    if (doesNotExist != null) {
      return doesNotExist();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(UserNameAlreadyExits value) userNameAlreadyExits,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(DoesNotExist value) doesNotExist,
    required TResult Function(NoInternet value) noInternet,
    required TResult Function(NoPhotos value) noPhotos,
  }) {
    return doesNotExist(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(UserNameAlreadyExits value)? userNameAlreadyExits,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(DoesNotExist value)? doesNotExist,
    TResult Function(NoInternet value)? noInternet,
    TResult Function(NoPhotos value)? noPhotos,
    required TResult orElse(),
  }) {
    if (doesNotExist != null) {
      return doesNotExist(this);
    }
    return orElse();
  }
}

abstract class DoesNotExist implements FirestoreFailure {
  const factory DoesNotExist() = _$DoesNotExist;
}

/// @nodoc
abstract class $NoInternetCopyWith<$Res> {
  factory $NoInternetCopyWith(
          NoInternet value, $Res Function(NoInternet) then) =
      _$NoInternetCopyWithImpl<$Res>;
}

/// @nodoc
class _$NoInternetCopyWithImpl<$Res>
    extends _$FirestoreFailureCopyWithImpl<$Res>
    implements $NoInternetCopyWith<$Res> {
  _$NoInternetCopyWithImpl(NoInternet _value, $Res Function(NoInternet) _then)
      : super(_value, (v) => _then(v as NoInternet));

  @override
  NoInternet get _value => super._value as NoInternet;
}

/// @nodoc
class _$NoInternet implements NoInternet {
  const _$NoInternet();

  @override
  String toString() {
    return 'FirestoreFailure.noInternet()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NoInternet);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() userNameAlreadyExits,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() doesNotExist,
    required TResult Function() noInternet,
    required TResult Function() noPhotos,
  }) {
    return noInternet();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? userNameAlreadyExits,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? doesNotExist,
    TResult Function()? noInternet,
    TResult Function()? noPhotos,
    required TResult orElse(),
  }) {
    if (noInternet != null) {
      return noInternet();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(UserNameAlreadyExits value) userNameAlreadyExits,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(DoesNotExist value) doesNotExist,
    required TResult Function(NoInternet value) noInternet,
    required TResult Function(NoPhotos value) noPhotos,
  }) {
    return noInternet(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(UserNameAlreadyExits value)? userNameAlreadyExits,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(DoesNotExist value)? doesNotExist,
    TResult Function(NoInternet value)? noInternet,
    TResult Function(NoPhotos value)? noPhotos,
    required TResult orElse(),
  }) {
    if (noInternet != null) {
      return noInternet(this);
    }
    return orElse();
  }
}

abstract class NoInternet implements FirestoreFailure {
  const factory NoInternet() = _$NoInternet;
}

/// @nodoc
abstract class $NoPhotosCopyWith<$Res> {
  factory $NoPhotosCopyWith(NoPhotos value, $Res Function(NoPhotos) then) =
      _$NoPhotosCopyWithImpl<$Res>;
}

/// @nodoc
class _$NoPhotosCopyWithImpl<$Res> extends _$FirestoreFailureCopyWithImpl<$Res>
    implements $NoPhotosCopyWith<$Res> {
  _$NoPhotosCopyWithImpl(NoPhotos _value, $Res Function(NoPhotos) _then)
      : super(_value, (v) => _then(v as NoPhotos));

  @override
  NoPhotos get _value => super._value as NoPhotos;
}

/// @nodoc
class _$NoPhotos implements NoPhotos {
  const _$NoPhotos();

  @override
  String toString() {
    return 'FirestoreFailure.noPhotos()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NoPhotos);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() userNameAlreadyExits,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() doesNotExist,
    required TResult Function() noInternet,
    required TResult Function() noPhotos,
  }) {
    return noPhotos();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? userNameAlreadyExits,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? doesNotExist,
    TResult Function()? noInternet,
    TResult Function()? noPhotos,
    required TResult orElse(),
  }) {
    if (noPhotos != null) {
      return noPhotos();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(UserNameAlreadyExits value) userNameAlreadyExits,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(DoesNotExist value) doesNotExist,
    required TResult Function(NoInternet value) noInternet,
    required TResult Function(NoPhotos value) noPhotos,
  }) {
    return noPhotos(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(UserNameAlreadyExits value)? userNameAlreadyExits,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(DoesNotExist value)? doesNotExist,
    TResult Function(NoInternet value)? noInternet,
    TResult Function(NoPhotos value)? noPhotos,
    required TResult orElse(),
  }) {
    if (noPhotos != null) {
      return noPhotos(this);
    }
    return orElse();
  }
}

abstract class NoPhotos implements FirestoreFailure {
  const factory NoPhotos() = _$NoPhotos;
}
